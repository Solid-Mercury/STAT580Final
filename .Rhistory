?sample
lrm.gen <- function(m, n, rank){
U <- matrix(rnorm(m*rank), nrow = m)
Vt <- matrix(rnorm(rank*n), nrow = rank)
return(U%*%Vt)
}
library(Matrix)
rankMatrix(lrm(m = 100, n = 100, rank = 20))
rankMatrix(lrm.gen(m = 100, n = 100, rank = 20))
dim(lrm.gen(3,5,1))
# function to add noise to a matrix. X is the true matrix and SNR is the desired signal-to-noise ratio. Large SNR preferred for imputing.
add_noise <- function(X, SNR){
noise <- rnorm(length(X))
# scale noise to satisfy SNR
noise <- sqrt(var(X[1:length(X)])/var(noise))/SNR * noise
# shape the noise into the shape of true matrix
dim(noise) <- dim(X)
return(X + noise)
}
lrm <- lrm.gen(10, 10, 2)
lrm_with_noise <- add_noise(lrm, 10)
lrm_with_noise
var((lrm_with_noise - lrm)[:])
var((lrm_with_noise - lrm)[1:length(lrm)])/var(lrm[1:length(lrm)])
sqrt(var((lrm_with_noise - lrm)[1:length(lrm)])/var(lrm[1:length(lrm)]))
sample(10, 2.1)
sample(10, 2.6)
sample(10, 2.6)
length(lrm)
lrm[80] <- NA
lrm
array(0, dim = c(2,2))
obs.gen <- function(X, p){
obs_ind <- sample(length(X), p*length(X))
omega <- array(0, dim = dim(X))
omega[obs_ind] <- 1
return(omega)
}
obs.gen(lrm, 0.5)
# function to set unobserved postions NA
set_NA <- function(X, omega){
return(X[omega == 0] <- NA)
}
set_NA(lrm, obs.gen(lrm, 0.5))
# function to set unobserved postions NA
set_NA <- function(X, omega){
X[omega == 0] <- NA
return(X)
}
set_NA(lrm, obs.gen(lrm, 0.5))
a <- list(c = 1, b = 2)
a
# generate low rank matrix, add noise and randomly remove
incomp.sim <- function(m,n,rank,SNR,p){
# generate
lrm <- lrm.gen(m,n,rank)
# add noise
incomp.sim <- add_noise(lrm, SNR)
#remove
incomp.sim <- set_NA(incomp.sim, obs.gen(incomp.sim, p))
res <- list(incomp <- incomp.sim, true = lrm)
return(res)
}
# generate low rank matrix, add noise and randomly remove
incomp.sim <- function(m,n,rank,SNR,p){
# generate
lrm <- lrm.gen(m,n,rank)
# add noise
incomp <- add_noise(lrm, SNR)
#remove
incomp <- set_NA(incomp, obs.gen(incomp, p))
res <- list(incomp <- incomp, true = lrm)
return(res)
}
incomp.sim(5,5,2,10,0.2)
# function to generate low rank matrix. m and n are number of rows and columns of the generated matrix. Rank is the desired rank of generated matrix.
lrm.gen <- function(m, n, rank){
U <- matrix(rnorm(m*rank), nrow = m)
Vt <- matrix(rnorm(rank*n), nrow = rank)
return(U%*%Vt)
}
# function to add noise to a matrix. X is the true matrix and SNR is the desired signal-to-noise ratio. Large SNR preferred for imputing.
add_noise <- function(X, SNR){
noise <- rnorm(length(X))
# scale noise to satisfy SNR
noise <- sqrt(var(X[1:length(X)])/var(noise))/SNR * noise
# shape the noise into the shape of true matrix
dim(noise) <- dim(X)
return(X + noise)
}
# function to generate p*100% missing postions in matrix X. Input p is in (0,1). Return a matrix of 0 and 1. (observed is 1).
obs.gen <- function(X, p){
obs_ind <- sample(length(X), p*length(X))
omega <- array(1, dim = dim(X))
omega[obs_ind] <- 0
return(omega)
}
# function to set unobserved postions NA
set_NA <- function(X, omega){
X[omega == 0] <- NA
return(X)
}
# generate low rank matrix, add noise and randomly remove
incomp.sim <- function(m,n,rank,SNR,p){
# generate
lrm <- lrm.gen(m,n,rank)
# add noise
incomp <- add_noise(lrm, SNR)
#remove
incomp <- set_NA(incomp, obs.gen(incomp, p))
res <- list(incomp <- incomp, true = lrm)
return(res)
}
incomp.sim(5,5,2,10,0.2)
x <- 1:100
y <- 2:101
df <- data.frame(x = x, y = y)
save(df, file = "test.Rda")
method <- rep(c(1,2,3,4),each = 5000)
head(method)
method[5001]
method[5000]
